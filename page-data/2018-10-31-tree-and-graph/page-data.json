{"componentChunkName":"component---src-templates-blog-post-js","path":"/2018-10-31-tree-and-graph/","result":{"data":{"site":{"siteMetadata":{"title":"Won"}},"markdownRemark":{"id":"520eb696-229e-584e-a109-47af85aa5e85","excerpt":"Tree-and-Graph Tree What is Tree? 그래프의 일종이다. 트리는 하나의 root node 를 가진다. 루트 노드는 0개 이상의 자식 노드를 갖는다. 자식노드 또한 0개 이상의 자식노드를 갖고 있고, 이는 반복적으로 정의 된다. child node…","html":"<h1>Tree-and-Graph</h1>\n<hr>\n<h1>Tree</h1>\n<h2>What is Tree?</h2>\n<ul>\n<li>그래프의 일종이다.</li>\n<li>트리는 하나의 <strong>root node</strong> 를 가진다.</li>\n<li>루트 노드는 0개 이상의 자식 노드를 갖는다.</li>\n<li>자식노드 또한 0개 이상의 자식노드를 갖고 있고, 이는 반복적으로 정의 된다.</li>\n<li><strong>child node</strong> 가 없는 노드를 <strong>leaf node</strong> 라고 한다.</li>\n<li><strong>leaf node</strong> 가 아닌 노드를 <strong>internal node</strong> 라고 한다.</li>\n<li>트리는 acyclic 해야 한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Node</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token builtin\">String</span> name<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token builtin\">Node</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> children<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Tree</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token builtin\">Node</span> root<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Binary Tree</h2>\n<ul>\n<li><strong>Binary Tree</strong> 는 자식노드가 최대 두 개인 트리를 말한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Node</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token builtin\">String</span> name<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token builtin\">Node</span> <span class=\"token keyword\">left</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token builtin\">Node</span> <span class=\"token keyword\">right</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Binary Search Tree</h2>\n<ul>\n<li>‘all left child nodes &#x3C;= <code class=\"language-text\">n</code> &#x3C; all right child nodes’ for all Node <code class=\"language-text\">n</code></li>\n</ul>\n<h2>Balanced Tree</h2>\n<ul>\n<li>Complete Binary Tree, AVL Tree, Red-Black Tree</li>\n</ul>\n<h2>Complete Binary Tree</h2>\n<ul>\n<li>트리의 모든 노드의 높이가 꽉 차 있는 Binary Tree 를 말한다.</li>\n<li>마지막 level 까지 꽉 차 있지 않아도 되지만 노드가 왼쪽에서 오른쪽으로 채워져야 한다.</li>\n</ul>\n<h2>Full Binary Tree</h2>\n<ul>\n<li>모든 노드의 자식노드가 없거나 정확히 두 개 있는 경우</li>\n</ul>\n<h2>Perfect Binary Tree</h2>\n<ul>\n<li>Complete Binary Tree <strong>and</strong> Full Binary Tree</li>\n</ul>\n<h2>Tree Traversals</h2>\n<h3>In-order Traversal</h3>\n<ul>\n<li>left branch, node, right branch</li>\n</ul>\n<h3>Pre-order Traversal</h3>\n<ul>\n<li>node, left branch, right branch</li>\n</ul>\n<h3>Post-order Traversal</h3>\n<ul>\n<li>left branch, right branch, node</li>\n</ul>\n<h2>Binary Heaps (Min, Max)</h2>\n<ul>\n<li>Complete Binary Tree</li>\n<li>각 노드의 원소가 자식들의 원소보다 작다(크다)</li>\n<li><strong>root node</strong> 는 전체 트리에서 가장 작은(큰) 원소가 된다.</li>\n<li><code class=\"language-text\">insert</code> <code class=\"language-text\">O(log n)</code></li>\n<li><code class=\"language-text\">extract_min</code> <code class=\"language-text\">O(log n)</code></li>\n</ul>\n<hr>\n<h1>Trie (prefix tree)</h1>\n<ul>\n<li>Seach Tree 이다.</li>\n<li>n-ary tree 이다.</li>\n<li>각 노드는 문자를 저장한다.</li>\n<li>스트링을 키로하는 동적 집합(dynamic set)이나 연관 배열(associative array)로 사용됨.</li>\n<li>root is empty string</li>\n</ul>\n<hr>\n<h1>Graph</h1>\n<ul>\n<li>노드와 그 노드를 연결하는 edge 를 하나로 모아 놓은 것</li>\n<li>모든 pair of vertices 간에 경로가 존재하는 그래프는 Connected Graph</li>\n<li>acyclic or cyclic 할 수 있다.</li>\n<li>그래프를 표현할 때는 <code class=\"language-text\">Adjacency list</code>, <code class=\"language-text\">Adjacency matrix</code> 를 사용한다.</li>\n<li><code class=\"language-text\">Adjacency matrix</code> 는 비효율 적이다.</li>\n</ul>\n<h2>Adjacency list</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Graph {\n\tpublic Node[] nodes;\n}\n\nclass Node {\n\tpublic String name;\n\tpublic Node[] children;\n}</code></pre></div>\n<h2>Adjacency matrix</h2>\n<ul>\n<li>NxN boolean matrix 이다. 간선이 존재하면 <code class=\"language-text\">matrix[i][j]</code> 는 <code class=\"language-text\">true</code> 아니면 <code class=\"language-text\">false</code></li>\n</ul>\n<hr>\n<h1>Graph Search</h1>\n<h2>DFS</h2>\n<ul>\n<li>깊이 우선 탐색은 시작 노드에서 다음 분기로 넘어가기 전에 시작한 분기를 완벽하게 탐색한다.</li>\n</ul>\n<h2>BFS</h2>\n<ul>\n<li>너피 우선 탐색은 시작 노드에서 시작해 인접한 노드를 먼저 탐색한다.</li>\n<li>Bidirectional BFS : \\( O(K^{d/2}) \\)</li>\n</ul>\n<blockquote>\n<p>Cyclic Graph 를 탐색할 때에는 visit 을 체크해줘야 한다.</p>\n</blockquote>\n<h1>ds #tree #graph</h1>","frontmatter":{"title":"Trees and Graphs","date":"October 30, 2018","description":null}}},"pageContext":{"slug":"/2018-10-31-tree-and-graph/","previous":{"fields":{"slug":"/python/2018-08-31-python-tips/"},"frontmatter":{"title":"Python Tips"}},"next":{"fields":{"slug":"/ios/2018-12-29-swift-type/"},"frontmatter":{"title":"What is type in Swift?"}}}},"staticQueryHashes":["240262808","2841359383"]}